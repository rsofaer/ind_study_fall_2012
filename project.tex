\documentclass{article}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{lastpage}
\usepackage{epstopdf}
\usepackage{fancyhdr}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newcommand{\cAuthor}{Raphael Sofaer}
\newcommand{\cTitle}{Implementing Low-Stretch Spanning Trees}
\pagestyle{fancy}
\lhead{\cAuthor}                                                 %
\rhead{\cTitle}  %
%\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}        

\title{\cTitle}
\author{\cAuthor}
\begin{document}
\maketitle

\section*{Abstract}
We implement an algorithm found in "Lower Stretch Spanning Trees", by Spielman et al., and evaluate its stretch performance on a variety of graphs.
\section*{Introduction}
\subsection*{Approximating with Trees}
In the last twenty years, there has been a growing effort to simplify graphs with trees - usually spanning trees - of low `stretch', in order to simplify corresponding Laplacian matrices and thereby rapidly solve linear problems involving symmetric and diagonally dominant matrices.
In 1995, Alon, Karp, Peleg and West\cite{akpw:game} built a zero-sum game in order to investigate the k-server problem\cite{wiki:kserver}, and the payoff in their game was adapted by Spielman et al.\cite{spielman:lower-stretch} into a focused measure of how closely a spanning subtree approximates a graph.

\begin{table}
    \begin{tabular}{|p{3cm}|l|p{5cm}|l|}
    \hline
    Author                      &         Year &                Stretch Metric                                                                              & Average Stretch Upper Bound                             \\ \hline
    Alon, Karp, Peleg, West     & 1995 &           cost(e) = 0 if $e \in T$, otherwise the weight of the unique cycle formed by adding e to T  &                         $exp(O(sqrt(log(n)*log(log(n))))$ \\ \hline
    Elkin, Emek, Spielman, Teng & 2005 & For each edge e=(u,v) in G, $stretch(e) = \frac{TreeDist(u,v)}{length(e)}$                            & O(log(n)*log(n)*log(log(n)))                            \\ \hline
    \end{tabular}
\end{table}
\subsection*{Solving with Approximate Trees}
In parallel to the improving tightness of graph-driven approximations to matrices, the solvers that use these approximations have also been getting faster and in some cases, simpler.
In 1991, P.M. Vaidya presented an unpublished manuscript\cite{vaidya} on constructing preconditioners using approximate subgraphs, which is widely referenced as seminal work\footnote{Unfortunately, we could not find this paper online, only many references to it.}.  This work was extended throughout the 1990s, and by 2004, the combination of recursively building these preconditioners, inexact Chebyshev methods, and more sophisticated graph simplification techniques reduced Vaidya's bound of $$O((dn)^{1.75}log(Îºf(A)/\epsilon))$$ for a SDD system of degree d with non-positive off diagonals to $$mlog^{O(1)}(m)+O(log(cond(A)/\epsilon))(m+n2^{O(\sqrt{lognlog logn})})$$\cite{nearly-linear-sparse}.
In 2011, Blelloch et al designed an SDD solver meant to work in parallel which approximately solves an SDD system in 
$O(mlog^{O(1)}nlog\frac{1}{\epsilon})$ work and $O(m^{1/3 + \theta}log\frac{1}{\epsilon})$, for any fixed $\theta>0$ (what is this theta?).\\


The latest advance in using approximate trees for solvers is Kelner et al\cite{comb-sdd}, who replace preconditioning with a direct solution.  They use an electric circuit metaphor, and optimize an electric flow by a stochastic gradient descent-like process within the spanning tree to get an approximate solution to the SDD linear system.  

\subsection*{Implementations}
Since Vaidya proposed these preconditioners, several relevant solvers have been written:\\
From 2001 to 2003, Sivan Toledo, Doron Chen, and Vladimir Rotkin developed TAUCS\cite{taucs}, a library of sparse linear solvers. 
It is implemented in C, and includes a variety of algorithms including Vaidya's preconditioners.\\
Yiannis Koutis wrote CMG\cite{CMG}, a solver which uses multigrid methods and combinatorial preconditioning to solve SDD matrices with non-positive off-diagonal elements.  It is written in C with a MATLAB interface.\\
Erik Boman working on graph preconditioners for Trilinos (Take this out before release if there's no public word)\\
Zhuo Feng and Zhiyu Zeng have implemented a solver which uses related methods in CUDA for the purpose of power grid analysis.\\
\section*{Results}
\subsection*{Vocabulary}
Some of the parts of our low stretch spanning tree algorithm operate on the reciprocals of the weight in a graph, since while a large number in a linear system usually indicates that a row and column are strongly linked, a large weight on a graph edge usually means that edge is less useful.  Spielman et al take $length(e)$ to be $1/weight(e)$, for an edge $e$.  In this paper and in our code, we use Kelner et al's vocabulary for links between graph nodes.  Rather than $weight(e)$, we refer to $resistance(e)$, and let $resistance(e)=1/conductance(e)$.  If `Lower Stretch Spanning Trees' is read in parallel to this, this difference should be kept in mind.  
\subsection{Implementation}
We implemented the algorithm of Spielman et al from `Lower Stretch Spanning Trees' in the Julia language\cite{juliawebsite}, a recent language combining dynamic typing with just-in-time compilation via LLVM to get good speed on easily written code.  We chose Julia for the ease of programming it gives without sacrificing good speed on custom datasets and interfaces.  We use the Julia Graphs library\cite{juliagraphs}, which is a port of the Boost Graph Library.  Our algorithm uses the graph interface provided by Graphs.jl to act on Julia's sparse matrix type, SparseMatrixCSC.  The implementation is not optimized for good running time, and we do not consider the running time to be representative of what a lower level or more highly parallelized implementation could reach.  However, the stretch we calculate can be used to estimate how well derived preconditioners or solvers might work on these types of graphs.\\
\subsection*{The Test Data}
We tested our algorithm on 3 datasets.  First we create a set of uniform random graphs at various sizes and densities, generated by the Julia Graphs library's erdos\_renyi\_graph function.\\
Second, we take a set of small world graphs at several sizes, neighborhood sizes, and rewiring chances.  These are generated by the Julia Graphs library's watts\_strogatz\_graph function.\\
Third, we take a dataset of the USA's highway network.  The dataset includes several regional subdivisions, such as the northeasters USA, and we run our algorithm on these subdivisions as well as the whole network.  We take the resistance of an edge to correspond to the length of a road link. \\
\end{document}